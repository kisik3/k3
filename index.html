<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Star Effect</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: black;
    }

    canvas {
      display: block;
    }
  </style>
</head>

<body>
  <canvas id="starCanvas"></canvas>
  <script>
    const canvas = document.getElementById('starCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const stars = [];
    const planets = [];
    const numStars = 5000; // Increased number of stars for a denser sky

    class Star {
      constructor() {
        this.reset();
      }

      reset() {
        this.x = Math.random() * canvas.width - canvas.width / 2;
        this.y = Math.random() * canvas.height - canvas.height / 2;
        this.z = Math.random() * canvas.width;
        this.size = Math.random() * 1.5 + 0.5; // Smaller size for more realistic stars
      }

      update() {
        this.z -= 1; // Slower movement
        if (this.z <= 0) {
          this.reset();
        }
      }

      draw() {
        const x = (this.x / this.z) * canvas.width + canvas.width / 2;
        const y = (this.y / this.z) * canvas.height + canvas.height / 2;
        const size = this.size / this.z * 100;

        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.fillStyle = 'white';
        ctx.fill();
      }
    }

    const moonTexture = new Image();
    moonTexture.src = 'moon.avif'; // Path to the moon texture file

    const sunTexture = new Image();
    sunTexture.src = 'sun.webp'; // Path to the sun texture file

    const venusTexture = new Image();
    venusTexture.src = '/textures/venus.png';

    const marsTexture = new Image();
    marsTexture.src = '/textures/mars.png';

    const earthTexture = new Image();
    earthTexture.src = '/textures/earth.png';

    const jupiterTexture = new Image();
    jupiterTexture.src = '/textures/jupiter.png';

    const saturnTexture = new Image();
    saturnTexture.src = '/textures/saturn.webp';

    const mercuryTexture = new Image();
    mercuryTexture.src = '/textures/mercury.png';

    const neptuneTexture = new Image();
    neptuneTexture.src = '/textures/neptune.jpg';

    const plutoTexture = new Image();
    plutoTexture.src = '/textures/pluto2.jpg';


    class Planet {
      constructor(color, text, extraSize = 0, texture = null, delay = 0) {
        this.color = color;
        this.text = text;
        this.extraSize = extraSize; // Additional size for the planet
        this.texture = texture; // Texture image for the planet
        this.delay = delay; // Delay before the planet appears
        this.elapsedTime = 0; // Tracks elapsed time since animation started
        this.reset();
      }

      reset() {
        const radius = Math.min(canvas.width, canvas.height) / 100; // Radius is 1/3 of the screen size
        const angle = Math.random() * Math.PI * 2; // Random angle for circular distribution
        // this.x = Math.cos(angle) * radius; // Position inside the circle
        // this.y = Math.sin(angle) * radius; // Position inside the circle

        this.x = Math.cos(angle) * radius; // Position inside the circle
        this.y = Math.sin(angle) * radius; // Position inside the circle

        this.z = canvas.width; // Start far away
        this.size = (Math.random() * 20 + 10 + this.extraSize); // Tripled size for planets, with extra size
      }

      update() {
        this.z -= 0.5; // Slower movement
        if (this.z <= 0) {
          this.reset();
          activePlanetIndex = (activePlanetIndex + 1) % planets.length; // Move to the next planet
        }
      }

      draw() {
        const x = (this.x / this.z) * canvas.width + canvas.width / 2;
        const y = (this.y / this.z) * canvas.height + canvas.height / 2;
        const size = this.size / this.z * 100;

        // Draw planet with texture if available
        if (this.texture && this.texture.complete) {
          ctx.save();
          ctx.beginPath();
          ctx.arc(x, y, size, 0, Math.PI * 2);
          ctx.clip(); // Clip the texture to the planet's circular shape
          ctx.drawImage(this.texture, x - size, y - size, size * 2, size * 2);
          ctx.restore();
        } else {
          // Fallback: Draw a solid color if texture is not loaded
          ctx.beginPath();
          ctx.arc(x, y, size, 0, Math.PI * 2);
          ctx.fillStyle = this.color;
          ctx.fill();
        }

        // Draw text above planet
        ctx.font = `${size / 3}px Arial`;
        ctx.fillStyle = 'white';
        ctx.textAlign = 'center';
        ctx.fillText(this.text, x, y - size - 10);
      }
    }

    function initStars() {
      for (let i = 0; i < numStars; i++) {
        stars.push(new Star());
      }
    }

    function initPlanets() {
      planets.push(new Planet('purple', 'K3', 0, venusTexture)); // Use moon texture
      planets.push(new Planet('pink', 'Friendship', 0, marsTexture)); // Use moon texture
      planets.push(new Planet('pink', 'Water Bus', 0, saturnTexture));
      // planets.push(new Planet('pink', 'Nha Trang', 0, moonTexture));
      planets.push(new Planet('pink', 'Q1', 0, earthTexture));
      planets.push(new Planet('lightcoral', 'Manhwa', 0, jupiterTexture)); // Use moon texture
      planets.push(new Planet('green', 'Thương', 0, moonTexture)); // Use moon texture
      planets.push(new Planet('pink', 'Mũi Né', 0, neptuneTexture));
      planets.push(new Planet('white', 'Q4', 0, saturnTexture)); // Use moon texture
      planets.push(new Planet('pink', 'Cần Giờ', 0, mercuryTexture));
      planets.push(new Planet('blue', 'Soul', 0, plutoTexture)); // Use moon texture
      planets.push(new Planet('yellow', 'S ♡ K', 10, sunTexture)); // Use sun texture for "I Love You" planet
    }

    let activePlanetIndex = 0; // Tracks the currently active planet
    let isPaused = false;      // Animation pause flag
    let showMessage = false;

    function animate() {
      if (isPaused) {
        if (showMessage) {
          // Draw paused frame with message
          const planet = planets[activePlanetIndex];
          const x = (planet.x / planet.z) * canvas.width + canvas.width / 2;
          const y = (planet.y / planet.z) * canvas.height + canvas.height / 2;
          const size = planet.size / planet.z * 100;
          drawMessageBox(x, y, size);
        }
        return;
      }
      showMessage = false;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      stars.forEach(star => {
        star.update();
        star.draw();
      });

      // Update and draw only the active planet
      planets[activePlanetIndex].update();
      planets[activePlanetIndex].draw();

      requestAnimationFrame(animate);
    }

    initStars();
    initPlanets();
    animate();

    canvas.addEventListener('touchstart', (e) => {
      if (!isPaused) {
        isPaused = true;
        return;
      }
      // If message box is showing, hide it and resume animation
      if (showMessage) {
        showMessage = false;
        isPaused = false;
        animate();
        return;
      }
      // If paused, check if touch is on planet
      const planet = planets[activePlanetIndex];
      const rect = canvas.getBoundingClientRect();
      const touch = e.touches[0];
      const touchX = touch.clientX - rect.left;
      const touchY = touch.clientY - rect.top;

      const x = (planet.x / planet.z) * canvas.width + canvas.width / 2;
      const y = (planet.y / planet.z) * canvas.height + canvas.height / 2;
      const size = planet.size / planet.z * 100;

      if (Math.hypot(touchX - x, touchY - y) <= size) {
        showMessage = true;
        drawMessageBox(x, y, size);
      } else {
        showMessage = false;
        animate();
      }
    });

    function drawMessageBox(x, y, size) {
      // Redraw everything
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      stars.forEach(star => star.draw());
      planets[activePlanetIndex].draw();

      // Message box settings
      const maxBoxWidth = 240;
      const padding = 12;
      const fontSize = 13;
      const lineHeight = fontSize * 1.5;
      const message = 'The sun dipped below the horizon, casting a warm golden glow over the tranquil lake. The water shimmered like a thousand diamonds, reflecting the hues of orange and pink that painted the sky.\nA gentle breeze rustled the leaves of the nearby trees, creating a soothing melody that echoed through the quiet evening';

      // Word wrap function
      function wrapText(text, maxWidth) {
        const lines = [];
        const paragraphs = text.split('\n');
        ctx.font = `${fontSize}px Arial`;
        for (const paragraph of paragraphs) {
          let words = paragraph.split(' ');
          let line = '';
          for (let n = 0; n < words.length; n++) {
            let testLine = line + words[n] + ' ';
            let metrics = ctx.measureText(testLine);
            let testWidth = metrics.width;
            if (testWidth > maxWidth - 2 * padding && n > 0) {
              lines.push(line.trim());
              line = words[n] + ' ';
            } else {
              line = testLine;
            }
          }
          lines.push(line.trim());
        }
        return lines;
      }

      // Wrap the message text
      const lines = wrapText(message, maxBoxWidth);
      const boxHeight = lines.length * lineHeight + 2 * padding;
      const boxWidth = maxBoxWidth;

      // Calculate available space in each direction
      const spaceAbove = y - size - 18;
      const spaceBelow = canvas.height - (y + size + 18);
      const spaceLeft = x - size - 18;
      const spaceRight = canvas.width - (x + size + 18);

      // Find the direction with the most space that fits the box
      let direction = 'above';
      let maxSpace = spaceAbove;

      if (spaceRight > maxSpace && spaceRight >= boxWidth) {
        direction = 'right';
        maxSpace = spaceRight;
      }
      if (spaceLeft > maxSpace && spaceLeft >= boxWidth) {
        direction = 'left';
        maxSpace = spaceLeft;
      }
      if (spaceBelow > maxSpace && spaceBelow >= boxHeight) {
        direction = 'below';
        maxSpace = spaceBelow;
      }

      // Default positions
      let boxX = x - boxWidth / 2;
      let boxY = y - size - boxHeight - 18;
      let anchorX = x;
      let anchorY = y - size;

      if (direction === 'right') {
        boxX = x + size + 18;
        boxY = y - boxHeight / 2;
        anchorX = x + size;
        anchorY = y;
      } else if (direction === 'left') {
        boxX = x - size - 18 - boxWidth;
        boxY = y - boxHeight / 2;
        anchorX = x - size;
        anchorY = y;
      } else if (direction === 'below') {
        boxX = x - boxWidth / 2;
        boxY = y + size + 18;
        anchorX = x;
        anchorY = y + size;
      }

      // Clamp box inside canvas
      if (boxX < 0) boxX = 0;
      if (boxX + boxWidth > canvas.width) boxX = canvas.width - boxWidth;
      if (boxY < 0) boxY = 0;
      if (boxY + boxHeight > canvas.height) boxY = canvas.height - boxHeight;

      // Draw box
      ctx.save();
      ctx.fillStyle = 'rgba(30,30,30,0.95)';
      ctx.strokeStyle = 'white';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.roundRect(boxX, boxY, boxWidth, boxHeight, 8);
      ctx.fill();
      ctx.stroke();

      // Draw anchor (triangle) from box to planet
      ctx.beginPath();
      if (direction === 'above') {
        // Anchor from bottom center of box to planet top
        const anchorBaseX = Math.max(boxX + 12, Math.min(x, boxX + boxWidth - 12));
        const anchorBaseY = boxY + boxHeight;
        ctx.moveTo(anchorBaseX - 10, anchorBaseY);
        ctx.lineTo(anchorX, anchorY);
        ctx.lineTo(anchorBaseX + 10, anchorBaseY);
      } else if (direction === 'below') {
        // Anchor from top center of box to planet bottom
        const anchorBaseX = Math.max(boxX + 12, Math.min(x, boxX + boxWidth - 12));
        const anchorBaseY = boxY;
        ctx.moveTo(anchorBaseX - 10, anchorBaseY);
        ctx.lineTo(anchorX, anchorY);
        ctx.lineTo(anchorBaseX + 10, anchorBaseY);
      } else if (direction === 'right') {
        // Anchor from left center of box to planet right
        const anchorBaseX = boxX;
        const anchorBaseY = Math.max(boxY + 12, Math.min(y, boxY + boxHeight - 12));
        ctx.moveTo(anchorBaseX, anchorBaseY - 10);
        ctx.lineTo(anchorX, anchorY);
        ctx.lineTo(anchorBaseX, anchorBaseY + 10);
      } else if (direction === 'left') {
        // Anchor from right center of box to planet left
        const anchorBaseX = boxX + boxWidth;
        const anchorBaseY = Math.max(boxY + 12, Math.min(y, boxY + boxHeight - 12));
        ctx.moveTo(anchorBaseX, anchorBaseY - 10);
        ctx.lineTo(anchorX, anchorY);
        ctx.lineTo(anchorBaseX, anchorBaseY + 10);
      }
      ctx.closePath();
      ctx.fillStyle = 'rgba(30,30,30,0.95)';
      ctx.fill();
      ctx.stroke();

      // Draw wrapped text
      ctx.fillStyle = 'white';
      ctx.font = `${fontSize}px Arial`;
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      let textY = boxY + padding;
      for (const line of lines) {
        ctx.fillText(line, boxX + padding, textY);
        textY += lineHeight;
      }
      ctx.restore();
    }

    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      planets.forEach(planet => planet.reset()); // Reset all planets on resize
    });
  </script>
</body>

</html>