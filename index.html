<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Star Effect</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: black;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="starCanvas"></canvas>
  <script>
    const canvas = document.getElementById('starCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const stars = [];
    const planets = [];
    const numStars = 5000; // Increased number of stars for a denser sky

    class Star {
      constructor() {
        this.reset();
      }

      reset() {
        this.x = Math.random() * canvas.width - canvas.width / 2;
        this.y = Math.random() * canvas.height - canvas.height / 2;
        this.z = Math.random() * canvas.width;
        this.size = Math.random() * 1.5 + 0.5; // Smaller size for more realistic stars
      }

      update() {
        this.z -= 1; // Slower movement
        if (this.z <= 0) {
          this.reset();
        }
      }

      draw() {
        const x = (this.x / this.z) * canvas.width + canvas.width / 2;
        const y = (this.y / this.z) * canvas.height + canvas.height / 2;
        const size = this.size / this.z * 100;

        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.fillStyle = 'white';
        ctx.fill();
      }
    }

    const moonTexture = new Image();
    moonTexture.src = 'moon.avif'; // Path to the moon texture file

    const sunTexture = new Image();
    sunTexture.src = 'sun.webp'; // Path to the sun texture file

    class Planet {
      constructor(color, text, extraSize = 0, texture = null, delay = 0) {
        this.color = color;
        this.text = text;
        this.extraSize = extraSize; // Additional size for the planet
        this.texture = texture; // Texture image for the planet
        this.delay = delay; // Delay before the planet appears
        this.elapsedTime = 0; // Tracks elapsed time since animation started
        this.reset();
      }

      reset() {
        const radius = Math.min(canvas.width, canvas.height) / 100; // Radius is 1/3 of the screen size
        const angle = Math.random() * Math.PI * 2; // Random angle for circular distribution
        // this.x = Math.cos(angle) * radius; // Position inside the circle
        // this.y = Math.sin(angle) * radius; // Position inside the circle

        this.x = Math.cos(angle) * radius; // Position inside the circle
        this.y = Math.sin(angle) * radius; // Position inside the circle

        this.z = canvas.width; // Start far away
        this.size = (Math.random() * 20 + 10 + this.extraSize); // Tripled size for planets, with extra size
      }

      update() {
        this.z -= 1; // Slower movement
        if (this.z <= 0) {
          this.reset();
          activePlanetIndex = (activePlanetIndex + 1) % planets.length; // Move to the next planet
        }
      }

      draw() {
        const x = (this.x / this.z) * canvas.width + canvas.width / 2;
        const y = (this.y / this.z) * canvas.height + canvas.height / 2;
        const size = this.size / this.z * 100;

        // Draw planet with texture if available
        if (this.texture && this.texture.complete) {
          ctx.save();
          ctx.beginPath();
          ctx.arc(x, y, size, 0, Math.PI * 2);
          ctx.clip(); // Clip the texture to the planet's circular shape
          ctx.drawImage(this.texture, x - size, y - size, size * 2, size * 2);
          ctx.restore();
        } else {
          // Fallback: Draw a solid color if texture is not loaded
          ctx.beginPath();
          ctx.arc(x, y, size, 0, Math.PI * 2);
          ctx.fillStyle = this.color;
          ctx.fill();
        }

        // Draw text above planet
        ctx.font = `${size / 3}px Arial`;
        ctx.fillStyle = 'white';
        ctx.textAlign = 'center';
        ctx.fillText(this.text, x, y - size - 10);
      }
    }

    function initStars() {
      for (let i = 0; i < numStars; i++) {
        stars.push(new Star());
      }
    }

    function initPlanets() {
      planets.push(new Planet('purple', 'K3', 0, moonTexture)); // Use moon texture
      planets.push(new Planet('pink', 'Friendship', 0, moonTexture)); // Use moon texture
      planets.push(new Planet('pink', 'Water Bus', 0, moonTexture)); 
      planets.push(new Planet('pink', 'Nha Trang', 0, moonTexture)); 
      planets.push(new Planet('pink', 'Q1', 0, moonTexture)); 
      planets.push(new Planet('white', 'Q4', 0, moonTexture)); // Use moon texture
      planets.push(new Planet('lightcoral', 'Manhwa', 0, moonTexture)); // Use moon texture
      planets.push(new Planet('green', 'Thương', 0, moonTexture)); // Use moon texture
      planets.push(new Planet('pink', 'Mũi Né', 0, moonTexture)); 
      planets.push(new Planet('pink', 'Cần Giờ', 0, moonTexture)); 
      planets.push(new Planet('blue', 'Soul', 0, moonTexture)); // Use moon texture
      planets.push(new Planet('yellow', 'S ♡ K', 10, sunTexture)); // Use sun texture for "I Love You" planet
    }

    let activePlanetIndex = 0; // Tracks the currently active planet

    function animate() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      stars.forEach(star => {
        star.update();
        star.draw();
      });

      // Update and draw only the active planet
      planets[activePlanetIndex].update();
      planets[activePlanetIndex].draw();

      requestAnimationFrame(animate);
    }

    initStars();
    initPlanets();
    animate();

    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      planets.forEach(planet => planet.reset()); // Reset all planets on resize
    });
  </script>
</body>
</html>