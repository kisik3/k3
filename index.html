<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Star Effect</title>
  <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: black;
    }

    canvas {
      display: block;
    }
  </style>
</head>

<body>
  <canvas id="starCanvas"></canvas>
  <script>
    const canvas = document.getElementById('starCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const stars = [];
    const planets = [];
    const numStars = 5000; // Increased number of stars for a denser sky

    class Star {
      constructor() {
        this.reset();
      }

      reset() {
        this.x = Math.random() * canvas.width - canvas.width / 2;
        this.y = Math.random() * canvas.height - canvas.height / 2;
        this.z = Math.random() * canvas.width;
        this.size = Math.random() * 1.5 + 0.5; // Smaller size for more realistic stars
      }

      update() {
        this.z -= 1; // Slower movement
        if (this.z <= 0) {
          this.reset();
        }
      }

      draw() {
        const x = (this.x / this.z) * canvas.width + canvas.width / 2;
        const y = (this.y / this.z) * canvas.height + canvas.height / 2;
        const size = this.size / this.z * 100;

        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.fillStyle = 'white';
        ctx.fill();
      }
    }

    const moonTexture = new Image();
    moonTexture.src = 'moon.avif'; // Path to the moon texture file

    const sunTexture = new Image();
    sunTexture.src = 'sun.webp'; // Path to the sun texture file

    const venusTexture = new Image();
    venusTexture.src = 'textures/venus.png';

    const marsTexture = new Image();
    marsTexture.src = 'textures/mars.png';

    const earthTexture = new Image();
    earthTexture.src = 'textures/earth.png';

    const jupiterTexture = new Image();
    jupiterTexture.src = 'textures/jupiter.png';

    const saturnTexture = new Image();
    saturnTexture.src = 'textures/saturn.webp';

    const mercuryTexture = new Image();
    mercuryTexture.src = 'textures/mercury.png';

    const neptuneTexture = new Image();
    neptuneTexture.src = 'textures/neptune.jpg';

    const plutoTexture = new Image();
    plutoTexture.src = 'textures/pluto2.jpg';


    class Planet {
      constructor(color, text, extraSize = 0, texture = null, delay = 0, message = '') {
        this.color = color;
        this.text = text;
        this.extraSize = extraSize; // Additional size for the planet
        this.texture = texture; // Texture image for the planet
        this.delay = delay; // Delay before the planet appears
        this.elapsedTime = 0; // Tracks elapsed time since animation started
        this.message = message; // <-- Add this line
        this.reset();
      }

      reset() {
        const radius = Math.min(canvas.width, canvas.height) / 100; // Radius is 1/3 of the screen size
        const angle = Math.random() * Math.PI * 2; // Random angle for circular distribution
        // this.x = Math.cos(angle) * radius; // Position inside the circle
        // this.y = Math.sin(angle) * radius; // Position inside the circle

        this.x = Math.cos(angle) * radius; // Position inside the circle
        this.y = Math.sin(angle) * radius; // Position inside the circle

        this.z = canvas.width; // Start far away
        this.size = (Math.random() * 20 + 10 + this.extraSize); // Tripled size for planets, with extra size
      }

      update() {
        this.z -= 0.5; // Slower movement
        if (this.z <= 0) {
          this.reset();
          activePlanetIndex = (activePlanetIndex + 1) % planets.length; // Move to the next planet
        }
      }

      draw() {
        const x = (this.x / this.z) * canvas.width + canvas.width / 2;
        const y = (this.y / this.z) * canvas.height + canvas.height / 2;
        const size = this.size / this.z * 100;

        // Draw planet with texture if available
        if (this.texture && this.texture.complete) {
          ctx.save();
          ctx.beginPath();
          ctx.arc(x, y, size, 0, Math.PI * 2);
          ctx.clip(); // Clip the texture to the planet's circular shape
          ctx.drawImage(this.texture, x - size, y - size, size * 2, size * 2);
          ctx.restore();
        } else {
          // Fallback: Draw a solid color if texture is not loaded
          ctx.beginPath();
          ctx.arc(x, y, size, 0, Math.PI * 2);
          ctx.fillStyle = this.color;
          ctx.fill();
        }

        // Draw text above planet
        ctx.font = `${size / 3}px Arial`;
        ctx.fillStyle = 'white';
        ctx.textAlign = 'center';
        ctx.fillText(this.text, x, y - size - 10);
      }
    }

    function initStars() {
      for (let i = 0; i < numStars; i++) {
        stars.push(new Star());
      }
    }

    function initPlanets() {
      planets.push(new Planet('purple', 'K3', 0, venusTexture, 0, 'Welcome to planet K3!'));
      planets.push(new Planet('pink', 'Friendship', 0, marsTexture, 0, 'This is the Friendship planet.'));
      planets.push(new Planet('pink', 'Water Bus', 0, saturnTexture, 0, 'Hop on the Water Bus!'));
      // planets.push(new Planet('pink', 'Nha Trang', 0, moonTexture, 0, 'Nha Trang is beautiful!'));
      planets.push(new Planet('pink', 'Q1', 0, earthTexture, 0, 'Welcome to Q1!'));
      planets.push(new Planet('lightcoral', 'Manhwa', 0, jupiterTexture, 0, 'Manhwa planet for comic lovers.'));
      planets.push(new Planet('green', 'Thương', 0, moonTexture, 0, 'Thương means love.'));
      planets.push(new Planet('pink', 'Mũi Né', 0, neptuneTexture, 0, 'Enjoy the beaches of Mũi Né.'));
      planets.push(new Planet('white', 'Q4', 0, saturnTexture, 0, 'Q4 is peaceful.'));
      planets.push(new Planet('pink', 'Cần Giờ', 0, mercuryTexture, 0, 'Cần Giờ - the green lung of Saigon.'));
      planets.push(new Planet('blue', 'Soul', 0, plutoTexture, 0, 'Soul planet for dreamers.'));
      planets.push(new Planet('yellow', 'S ♡ K', 10, sunTexture, 0, 'S ♡ K - The planet of love!'));
    }

    let activePlanetIndex = 0; // Tracks the currently active planet
    let isPaused = false;      // Animation pause flag
    let showMessage = false;

    function animate() {
      if (isPaused) {
        if (showMessage) {
          // Draw paused frame with message
          const planet = planets[activePlanetIndex];
          const x = (planet.x / planet.z) * canvas.width + canvas.width / 2;
          const y = (planet.y / planet.z) * canvas.height + canvas.height / 2;
          const size = planet.size / planet.z * 100;
          drawMessageBox(x, y, size);
        }
        return;
      }
      showMessage = false;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      stars.forEach(star => {
        star.update();
        star.draw();
      });

      // Update and draw only the active planet
      planets[activePlanetIndex].update();
      planets[activePlanetIndex].draw();

      requestAnimationFrame(animate);
    }

    initStars();
    initPlanets();
    animate();

    canvas.addEventListener('touchstart', (e) => {
      if (!isPaused) {
        isPaused = true;
        return;
      }
      // If message box is showing, hide it and resume animation
      if (showMessage) {
        showMessage = false;
        isPaused = false;
        animate();
        return;
      }
      // If paused, check if touch is on planet
      const planet = planets[activePlanetIndex];
      const rect = canvas.getBoundingClientRect();
      const touch = e.touches[0];
      const touchX = touch.clientX - rect.left;
      const touchY = touch.clientY - rect.top;

      const x = (planet.x / planet.z) * canvas.width + canvas.width / 2;
      const y = (planet.y / planet.z) * canvas.height + canvas.height / 2;
      const size = planet.size / planet.z * 100;

      if (Math.hypot(touchX - x, touchY - y) <= size) {
        showMessage = true;
        shouldRestartTyping = true; // <-- set this flag
        drawMessageBox(x, y, size);
      } else {
        showMessage = false;
        animate();
      }
    });

    // Add this at the top level
    let shouldRestartTyping = false;

    // Add these variables at the top-level (outside drawMessageBox)
    let typingIndex = 0;
    let typingLines = [];
    let typingDone = false;
    let typingStartTime = 0;
    let typingSpeed = 30; // ms per character
    let cursorVisible = true;
    let lastCursorBlink = 0;
    const cursorBlinkInterval = 500; // ms

    function startTypingEffect(message, fontSize, maxBoxWidth, padding) {
      typingIndex = 0;
      typingDone = false;
      typingStartTime = performance.now();
      typingLines = [];

      // Word wrap function (same as before)
      function wrapText(text, maxWidth) {
        const lines = [];
        const paragraphs = text.split('\n');
        ctx.font = `${fontSize}px "VT323", "Share Tech Mono", "Orbitron", "Courier New", monospace`;
        for (const paragraph of paragraphs) {
          let words = paragraph.split(' ');
          let line = '';
          for (let n = 0; n < words.length; n++) {
            let testLine = line + words[n] + ' ';
            let metrics = ctx.measureText(testLine);
            let testWidth = metrics.width;
            if (testWidth > maxWidth - 2 * padding && n > 0) {
              lines.push(line.trim());
              line = words[n] + ' ';
            } else {
              line = testLine;
            }
          }
          lines.push(line.trim());
        }
        return lines;
      }

      typingLines = wrapText(message, maxBoxWidth);
    }

    function drawMessageBox(x, y, size) {
      const planet = planets[activePlanetIndex];
      const maxBoxWidth = 300;
      const padding = 16;
      const fontSize = 14;
      const lineHeight = 18;
      const message = planet.message || 'This is a neon-style message box!\nYou can put any text here.\nIt will wrap and look cool.';

      // Only restart typing effect if needed
      if (shouldRestartTyping) {
        startTypingEffect(message, fontSize, maxBoxWidth, padding);
        shouldRestartTyping = false;
      }

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      stars.forEach(star => star.draw());
      planets[activePlanetIndex].draw();

      // Calculate how many characters to show
      let now = performance.now();
      let charsToShow = Math.floor((now - typingStartTime) / typingSpeed);
      let totalChars = typingLines.join('\n').length;
      if (charsToShow >= totalChars) {
        charsToShow = totalChars;
        typingDone = true;
      }

      // Prepare lines with typing effect
      let displayLines = [];
      let charsLeft = charsToShow;
      for (let line of typingLines) {
        if (charsLeft >= line.length) {
          displayLines.push(line);
          charsLeft -= line.length + 1; // +1 for the newline
        } else {
          displayLines.push(line.slice(0, Math.max(0, charsLeft)));
          break;
        }
      }

      // Outer neon box
      const boxHeight = typingLines.length * lineHeight + 2 * padding;
      const boxWidth = maxBoxWidth;
      const connectorLength = 80;
      let boxX = x - boxWidth / 2;
      let boxY = y - size - boxHeight - connectorLength;
      let anchorX = x;
      let anchorY = y - size;

      // Clamp box inside canvas
      if (boxX < 0) boxX = 0;
      if (boxX + boxWidth > canvas.width) boxX = canvas.width - boxWidth;
      if (boxY < 0) boxY = 0;

      ctx.save();
      ctx.strokeStyle = '#00f6ff';
      ctx.lineWidth = 3;
      ctx.shadowColor = '#00f6ff';
      ctx.shadowBlur = 20;
      ctx.roundRect(boxX, boxY, boxWidth, boxHeight, 12);
      ctx.stroke();

      ctx.shadowBlur = 0;

      // Draw equilateral triangles at corners
      ctx.fillStyle = '#00f6ff';
      const triSize = 10;
      const triHeight = triSize * Math.sqrt(3) / 2;

      // Top-left
      ctx.beginPath();
      ctx.moveTo(boxX, boxY);
      ctx.lineTo(boxX - triHeight, boxY + triSize / 2);
      ctx.lineTo(boxX + triSize / 2, boxY - triHeight);
      ctx.closePath();
      ctx.fill();

      // Top-right
      ctx.beginPath();
      ctx.moveTo(boxX + boxWidth, boxY);
      ctx.lineTo(boxX + boxWidth + triHeight, boxY + triSize / 2);
      ctx.lineTo(boxX + boxWidth - triSize / 2, boxY - triHeight);
      ctx.closePath();
      ctx.fill();

      // Bottom-left
      ctx.beginPath();
      ctx.moveTo(boxX, boxY + boxHeight);
      ctx.lineTo(boxX - triHeight, boxY + boxHeight - triSize / 2);
      ctx.lineTo(boxX + triSize / 2, boxY + boxHeight + triHeight);
      ctx.closePath();
      ctx.fill();

      // Bottom-right
      ctx.beginPath();
      ctx.moveTo(boxX + boxWidth, boxY + boxHeight);
      ctx.lineTo(boxX + boxWidth + triHeight, boxY + boxHeight - triSize / 2);
      ctx.lineTo(boxX + boxWidth - triSize / 2, boxY + boxHeight + triHeight);
      ctx.closePath();
      ctx.fill();

      // Connector line & complete triangle pointer
      ctx.beginPath();
      const anchorBaseX = Math.max(boxX + 20, Math.min(x, boxX + boxWidth - 20));
      const anchorBaseY = boxY + boxHeight;
      ctx.moveTo(anchorBaseX, anchorBaseY);
      ctx.lineTo(anchorX, anchorY);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(anchorX, anchorY); // tip
      ctx.lineTo(anchorX - 10, anchorY - 18);
      ctx.lineTo(anchorX + 10, anchorY - 18);
      ctx.closePath();
      ctx.fillStyle = '#00f6ff';
      ctx.globalAlpha = 0.85;
      ctx.fill();
      ctx.globalAlpha = 1.0;
      ctx.stroke();

      // Draw planet name above the outer neon box, aligned left
      ctx.save();
      ctx.font = `bold 16px "VT323", "Share Tech Mono", "Orbitron", "Courier New", monospace`;
      ctx.fillStyle = '#00f6ff';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'bottom';
      ctx.shadowColor = '#00f6ff';
      ctx.shadowBlur = 12;
      ctx.fillText(planets[activePlanetIndex].text, boxX + padding, boxY - 8);
      ctx.shadowBlur = 0;
      ctx.restore();

      // Draw typing text with blinking cursor
      ctx.fillStyle = '#00f6ff';
      ctx.font = `${fontSize}px "VT323", "Share Tech Mono", "Orbitron", "Courier New", monospace`;
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      let textY = boxY + padding;
      for (let i = 0; i < displayLines.length; i++) {
        ctx.fillText(displayLines[i], boxX + padding, textY);
        textY += lineHeight;
      }

      // Blinking cursor
      let cursorX = boxX + padding + ctx.measureText(displayLines[displayLines.length - 1] || '').width;
      let cursorY = boxY + padding + (displayLines.length - 1) * lineHeight;
      if (!typingDone) {
        if (now - lastCursorBlink > cursorBlinkInterval) {
          cursorVisible = !cursorVisible;
          lastCursorBlink = now;
        }
        if (cursorVisible) {
          ctx.fillRect(cursorX, cursorY, 10, fontSize + 2);
        }
        requestAnimationFrame(() => drawMessageBox(x, y, size));
      } else {
        // Show steady cursor at end when done
        ctx.fillRect(cursorX, cursorY, 10, fontSize + 2);
      }

      ctx.restore();
    }

    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      planets.forEach(planet => planet.reset()); // Reset all planets on resize
    });
  </script>
</body>

</html>