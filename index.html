<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Star Effect</title>
  <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: black;
    }

    canvas {
      display: block;
    }
  </style>
</head>

<body>
  <canvas id="starCanvas"></canvas>
  <script>
    const canvas = document.getElementById('starCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const stars = [];
    const planets = [];
    const numStars = 5000; // Increased number of stars for a denser sky

    class Star {
      constructor() {
        this.reset();
      }

      reset() {
        this.x = Math.random() * canvas.width - canvas.width / 2;
        this.y = Math.random() * canvas.height - canvas.height / 2;
        this.z = Math.random() * canvas.width;
        this.size = Math.random() * 1.5 + 0.5; // Smaller size for more realistic stars
      }

      update() {
        this.z -= 1; // Slower movement
        if (this.z <= 0) {
          this.reset();
        }
      }

      draw() {
        const x = (this.x / this.z) * canvas.width + canvas.width / 2;
        const y = (this.y / this.z) * canvas.height + canvas.height / 2;
        const size = this.size / this.z * 100;

        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.fillStyle = 'white';
        ctx.fill();
      }
    }

    const moonTexture = new Image();
    moonTexture.src = 'moon.avif'; // Path to the moon texture file

    const sunTexture = new Image();
    sunTexture.src = 'sun.webp'; // Path to the sun texture file

    const venusTexture = new Image();
    venusTexture.src = 'textures/venus.png';

    const marsTexture = new Image();
    marsTexture.src = 'textures/mars.png';

    const earthTexture = new Image();
    earthTexture.src = 'textures/earth.png';

    const jupiterTexture = new Image();
    jupiterTexture.src = 'textures/jupiter.png';

    const saturnTexture = new Image();
    saturnTexture.src = 'textures/saturn.webp';

    const mercuryTexture = new Image();
    mercuryTexture.src = 'textures/mercury.png';

    const neptuneTexture = new Image();
    neptuneTexture.src = 'textures/neptune.jpg';

    const plutoTexture = new Image();
    plutoTexture.src = 'textures/pluto2.jpg';


    class Planet {
      constructor(color, text, extraSize = 0, texture = null, delay = 0) {
        this.color = color;
        this.text = text;
        this.extraSize = extraSize; // Additional size for the planet
        this.texture = texture; // Texture image for the planet
        this.delay = delay; // Delay before the planet appears
        this.elapsedTime = 0; // Tracks elapsed time since animation started
        this.reset();
      }

      reset() {
        const radius = Math.min(canvas.width, canvas.height) / 100; // Radius is 1/3 of the screen size
        const angle = Math.random() * Math.PI * 2; // Random angle for circular distribution
        // this.x = Math.cos(angle) * radius; // Position inside the circle
        // this.y = Math.sin(angle) * radius; // Position inside the circle

        this.x = Math.cos(angle) * radius; // Position inside the circle
        this.y = Math.sin(angle) * radius; // Position inside the circle

        this.z = canvas.width; // Start far away
        this.size = (Math.random() * 20 + 10 + this.extraSize); // Tripled size for planets, with extra size
      }

      update() {
        this.z -= 0.5; // Slower movement
        if (this.z <= 0) {
          this.reset();
          activePlanetIndex = (activePlanetIndex + 1) % planets.length; // Move to the next planet
        }
      }

      draw() {
        const x = (this.x / this.z) * canvas.width + canvas.width / 2;
        const y = (this.y / this.z) * canvas.height + canvas.height / 2;
        const size = this.size / this.z * 100;

        // Draw planet with texture if available
        if (this.texture && this.texture.complete) {
          ctx.save();
          ctx.beginPath();
          ctx.arc(x, y, size, 0, Math.PI * 2);
          ctx.clip(); // Clip the texture to the planet's circular shape
          ctx.drawImage(this.texture, x - size, y - size, size * 2, size * 2);
          ctx.restore();
        } else {
          // Fallback: Draw a solid color if texture is not loaded
          ctx.beginPath();
          ctx.arc(x, y, size, 0, Math.PI * 2);
          ctx.fillStyle = this.color;
          ctx.fill();
        }

        // Draw text above planet
        ctx.font = `${size / 3}px Arial`;
        ctx.fillStyle = 'white';
        ctx.textAlign = 'center';
        ctx.fillText(this.text, x, y - size - 10);
      }
    }

    function initStars() {
      for (let i = 0; i < numStars; i++) {
        stars.push(new Star());
      }
    }

    function initPlanets() {
      planets.push(new Planet('purple', 'K3', 0, venusTexture)); // Use moon texture
      planets.push(new Planet('pink', 'Friendship', 0, marsTexture)); // Use moon texture
      planets.push(new Planet('pink', 'Water Bus', 0, saturnTexture));
      // planets.push(new Planet('pink', 'Nha Trang', 0, moonTexture));
      planets.push(new Planet('pink', 'Q1', 0, earthTexture));
      planets.push(new Planet('lightcoral', 'Manhwa', 0, jupiterTexture)); // Use moon texture
      planets.push(new Planet('green', 'Thương', 0, moonTexture)); // Use moon texture
      planets.push(new Planet('pink', 'Mũi Né', 0, neptuneTexture));
      planets.push(new Planet('white', 'Q4', 0, saturnTexture)); // Use moon texture
      planets.push(new Planet('pink', 'Cần Giờ', 0, mercuryTexture));
      planets.push(new Planet('blue', 'Soul', 0, plutoTexture)); // Use moon texture
      planets.push(new Planet('yellow', 'S ♡ K', 10, sunTexture)); // Use sun texture for "I Love You" planet
    }

    let activePlanetIndex = 0; // Tracks the currently active planet
    let isPaused = false;      // Animation pause flag
    let showMessage = false;

    function animate() {
      if (isPaused) {
        if (showMessage) {
          // Draw paused frame with message
          const planet = planets[activePlanetIndex];
          const x = (planet.x / planet.z) * canvas.width + canvas.width / 2;
          const y = (planet.y / planet.z) * canvas.height + canvas.height / 2;
          const size = planet.size / planet.z * 100;
          drawMessageBox(x, y, size);
        }
        return;
      }
      showMessage = false;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      stars.forEach(star => {
        star.update();
        star.draw();
      });

      // Update and draw only the active planet
      planets[activePlanetIndex].update();
      planets[activePlanetIndex].draw();

      requestAnimationFrame(animate);
    }

    initStars();
    initPlanets();
    animate();

    canvas.addEventListener('touchstart', (e) => {
      if (!isPaused) {
        isPaused = true;
        return;
      }
      // If message box is showing, hide it and resume animation
      if (showMessage) {
        showMessage = false;
        isPaused = false;
        animate();
        return;
      }
      // If paused, check if touch is on planet
      const planet = planets[activePlanetIndex];
      const rect = canvas.getBoundingClientRect();
      const touch = e.touches[0];
      const touchX = touch.clientX - rect.left;
      const touchY = touch.clientY - rect.top;

      const x = (planet.x / planet.z) * canvas.width + canvas.width / 2;
      const y = (planet.y / planet.z) * canvas.height + canvas.height / 2;
      const size = planet.size / planet.z * 100;

      if (Math.hypot(touchX - x, touchY - y) <= size) {
        showMessage = true;
        drawMessageBox(x, y, size);
      } else {
        showMessage = false;
        animate();
      }
    });

    function drawMessageBox(x, y, size) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      stars.forEach(star => star.draw());
      planets[activePlanetIndex].draw();

      // Message box settings
      const maxBoxWidth = 300;
      const padding = 16;
      const fontSize = 14;
      const lineHeight = 18;
      const message = 'This is a neon-style message box!\nYou can put any text here.\nIt will wrap and look cool.';

      // Word wrap function
      function wrapText(text, maxWidth) {
        const lines = [];
        const paragraphs = text.split('\n');
        ctx.font = `${fontSize}px monospace`;
        for (const paragraph of paragraphs) {
          let words = paragraph.split(' ');
          let line = '';
          for (let n = 0; n < words.length; n++) {
            let testLine = line + words[n] + ' ';
            let metrics = ctx.measureText(testLine);
            let testWidth = metrics.width;
            if (testWidth > maxWidth - 2 * padding && n > 0) {
              lines.push(line.trim());
              line = words[n] + ' ';
            } else {
              line = testLine;
            }
          }
          lines.push(line.trim());
        }
        return lines;
      }

      // Wrap the message text
      const lines = wrapText(message, maxBoxWidth);
      const boxHeight = lines.length * lineHeight + 2 * padding;
      const boxWidth = maxBoxWidth;

      // Move the box farther above the planet for a clear connector
      const connectorLength = 80; // distance from planet to box
      let boxX = x - boxWidth / 2;
      let boxY = y - size - boxHeight - connectorLength;
      let anchorX = x;
      let anchorY = y - size;

      // Clamp box inside canvas
      if (boxX < 0) boxX = 0;
      if (boxX + boxWidth > canvas.width) boxX = canvas.width - boxWidth;
      if (boxY < 0) boxY = 0;

      // Outer neon box
      ctx.save();
      ctx.strokeStyle = '#00f6ff';
      ctx.lineWidth = 3;
      ctx.shadowColor = '#00f6ff';
      ctx.shadowBlur = 20;
      ctx.roundRect(boxX, boxY, boxWidth, boxHeight, 12);
      ctx.stroke();

      ctx.shadowBlur = 0; // Disable shadow for inner details

      // Draw an equilateral triangle at each corner, pointing outward from the box
      ctx.fillStyle = '#00f6ff';
      const triSize = 10; // Smaller side length of the equilateral triangle
      const triHeight = triSize * Math.sqrt(3) / 2;

      // Top-left corner (points to top-left)
      ctx.beginPath();
      ctx.moveTo(boxX, boxY); // corner (triangle tip)
      ctx.lineTo(boxX - triHeight, boxY + triSize / 2);
      ctx.lineTo(boxX + triSize / 2, boxY - triHeight);
      ctx.closePath();
      ctx.fill();

      // Top-right corner (points to top-right)
      ctx.beginPath();
      ctx.moveTo(boxX + boxWidth, boxY); // corner (triangle tip)
      ctx.lineTo(boxX + boxWidth + triHeight, boxY + triSize / 2);
      ctx.lineTo(boxX + boxWidth - triSize / 2, boxY - triHeight);
      ctx.closePath();
      ctx.fill();

      // Bottom-left corner (points to bottom-left)
      ctx.beginPath();
      ctx.moveTo(boxX, boxY + boxHeight); // corner (triangle tip)
      ctx.lineTo(boxX - triHeight, boxY + boxHeight - triSize / 2);
      ctx.lineTo(boxX + triSize / 2, boxY + boxHeight + triHeight);
      ctx.closePath();
      ctx.fill();

      // Bottom-right corner (points to bottom-right)
      ctx.beginPath();
      ctx.moveTo(boxX + boxWidth, boxY + boxHeight); // corner (triangle tip)
      ctx.lineTo(boxX + boxWidth + triHeight, boxY + boxHeight - triSize / 2);
      ctx.lineTo(boxX + boxWidth - triSize / 2, boxY + boxHeight + triHeight);
      ctx.closePath();
      ctx.fill();

      // Bottom horizontal lines (optional, keep or remove as you like)
      ctx.beginPath();
      for (let i = 0; i < 3; i++) {
        ctx.moveTo(boxX + 10 + i * 30, boxY + boxHeight + 5);
        ctx.lineTo(boxX + 30 + i * 30, boxY + boxHeight + 5);
      }
      ctx.stroke();

      // Connector line & node (from bottom center of box to planet top)
      ctx.beginPath();
      const anchorBaseX = Math.max(boxX + 20, Math.min(x, boxX + boxWidth - 20));
      const anchorBaseY = boxY + boxHeight;

      // Draw a straight connector from the bottom center of the box to the top of the planet
      ctx.moveTo(anchorBaseX, anchorBaseY);
      ctx.lineTo(anchorX, anchorY);

      // Draw a complete triangle at the planet anchor for a pointer effect
      ctx.beginPath();
      ctx.moveTo(anchorX, anchorY); // tip of the triangle (points to planet)
      ctx.lineTo(anchorX - 10, anchorY - 18); // left base
      ctx.lineTo(anchorX + 10, anchorY - 18); // right base
      ctx.closePath();
      ctx.fillStyle = '#00f6ff';
      ctx.globalAlpha = 0.85;
      ctx.fill();
      ctx.globalAlpha = 1.0;
      ctx.stroke();

      // Draw wrapped text
      ctx.fillStyle = '#00f6ff';
      ctx.font = `${fontSize}px "VT323", "Share Tech Mono", "Orbitron", "Courier New", monospace`; // Digital font stack
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      let textY = boxY + padding;
      for (const line of lines) {
        ctx.fillText(line, boxX + padding, textY);
        textY += lineHeight;
      }

      // Draw planet name above the outer neon box, aligned left
      ctx.save();
      ctx.font = `bold 16px "VT323", "Share Tech Mono", "Orbitron", "Courier New", monospace`; // Digital font stack
      ctx.fillStyle = '#00f6ff';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'bottom';
      ctx.shadowColor = '#00f6ff';
      ctx.shadowBlur = 12;
      ctx.fillText(planets[activePlanetIndex].text, boxX + padding, boxY - 8);
      ctx.shadowBlur = 0;
      ctx.restore();
    }

    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      planets.forEach(planet => planet.reset()); // Reset all planets on resize
    });
  </script>
</body>

</html>